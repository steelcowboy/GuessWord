#!/usr/bin/env python2
# -*- coding: utf-8 -*-

#-----------------------------------------------------------------------
#~ The MIT License (MIT)
#~ 
#~ Copyright (c) 2015 James Heald <jhdoubleoseven@gmail.com>
#~ 
#~ Permission is hereby granted, free of charge, to any person obtaining a copy
#~ of this software and associated documentation files (the "Software"), to deal
#~ in the Software without restriction, including without limitation the rights
#~ to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
#~ copies of the Software, and to permit persons to whom the Software is
#~ furnished to do so, subject to the following conditions:
#~ 
#~ The above copyright notice and this permission notice shall be included in all
#~ copies or substantial portions of the Software.
#~ 
#~ THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
#~ IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
#~ FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
#~ AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
#~ LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
#~ OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
#~ SOFTWARE.
#-----------------------------------------------------------------------

# Import our modules
from sys import exit
import random, os, argparse, string
from os.path import exists
import imp

parser = argparse.ArgumentParser()
parser.add_argument("-d", "--dictionary", 
                    help="specify text file for words (must be encoded in hex)")
parser.add_argument("-l", "--level", type=int, choices=[1,2,3],
					help="""choose a difficulty level (default is 1): 
					level 1 is fifteen incorrect guesses,
					level 2 is ten incorrect guesses
					and level 3 is five incorrect guesses
					""")
parser.add_argument("-r", "--random", action="store_true",
					help = "choose random word from dictionary")
parser.add_argument("--no-color", action="store_true",
					help = "turn off color")
args = parser.parse_args()

## Functions
# This retrieves the word to guess 
def get_word():
	# If the random argument was selected      
	if args.random:  
		# Check if the file exists  
		if exists("random.txt"):  
			dict_file = "random.txt" 
			# Open the file then make a list of all the lines       
			hang_list = open(dict_file).read().splitlines()
			# Remove any blank lines    
			hang_list = filter(None, hang_list)
			# Choose a random word from the list            
			word = random.choice(hang_list)
			# Decode the word from hex
			word = word.decode('hex')	
		# If the dictionary file does not exist we'll get it from the internet				  
		else:      
			import requests
			word_site = "http://svnweb.freebsd.org/csrg/share/dict/words?view=co&content-type=text/plain"
			response = requests.get(word_site)
			words = response.content.splitlines()
			word = random.choice(words)
	
	# Else if the dictionary argument was selected	
	elif args.dictionary:
		# See args.random for explanation
		dict_file = args.dictionary
		hang_list = open(dict_file).read().splitlines()
		hang_list = filter(None, hang_list) 
		word = random.choice(hang_list)
		word = word.decode('hex')
	
	# If none were selected print an error and exit
	else:
		print """
		No dictionary selected. Please either use a random word with
		the "-r" option or choose a dictionary file with "-d".
		"""
		exit(0)	
	# Change any uppercase letters in the word to lowercase
	word = word.lower()
	return word

# Based on the selected level define how many incorrect guesses. 
# If none selected, default to 15
def get_tries():
	if args.level == 1:
		tries = 15 
	elif args.level == 2:
		tries = 10 
	elif args.level == 3:
		tries = 5
	else:
		tries = 15
	return tries
	
# This tells us our progress	
def compare_words(word):
	# First create a blank variable for progress
	new_word = ''
	# Loop through the letters in our word
	for char in word:
		# If the character in the word matches one we've guessed, write it
		if char in guesses: 
			new_word += char
		# Otherwise leave it blank until we guess it
		else:
			new_word += " _ "
	# This tells the function to output, so 
	# we store the value of the function itself in a new variable
	return new_word	

## Game body

# First set up the messages

# Check to see if termcolor exists
try:
	imp.find_module('termcolor')
	found = True
except ImportError:
	found = False

# This may eventually be replaced with classes or dictionaries or something
if args.no_color:
	correct_msg = "Correct!"
	incor_msg = "Incorrect. You have %d tries left."
	win_msg = "You won! Good job! The word was %s"
	lose_msg = "You lose! The word was %s" 
	err_msg_let = "Please enter only letters."
	err_msg_one = "Please enter only one character."
	err_msg_gss = "That letter has already been guessed." 
	
elif found:
	from termcolor import colored
	correct_msg = colored("Correct!", 'green', attrs=['bold'])
	incor_msg = colored("Incorrect. You have %d tries left.", 'red', attrs=['bold'])
	win_msg = colored("You won! Good job! ", 'green', attrs=['bold']) + "The word was %s"
	lose_msg = colored("You lose!", 'red', attrs=['bold']) + "The word was %s" 
	err_msg_let = colored("Please enter only letters.", 'magenta', attrs=['bold'])
	err_msg_one = colored("Please enter only one character.", 'magenta', attrs=['bold'])
	err_msg_gss = colored("That letter has already been guessed.", 'red', attrs=['bold'])
	
else:
	correct_msg = "\033[1;32mCorrect!\033[0m"
	incor_msg = "\033[1;31mIncorrect. You have %d tries left.\033[0m"
	win_msg = "\033[1;32mYou won! Good job!\033[0m The word was %s"
	lose_msg = "\033[1;31mYou lose!\033[0m The word was %s"
	err_msg_let = "\033[1;35mPlease enter only letters.\033[0m"
	err_msg_one = "\033[1;35mPlease enter only one character.\033[0m"
	err_msg_gss = "\033[1;31mThat letter has already been guessed.\033[0m"

# Set a variable to count how many times the while loop has looped
counter = 1	

# Main loop
while True:
	# This initializes (and later resets) our variables
	if counter == 1:
		guesses = ''
		word = get_word()	
		tries = get_tries()
	else:
		pass
		
	counter += 1
	
	# This iniatializes the new word
	new_word = compare_words(word)
	
	# We use a while loop to keep prompting the user for a single letter
	while True:
		letter = raw_input("Guess a letter: ")
		if len(letter) == 1:
			# Until the input is one letter (not a symbol or number)
			if letter in string.letters:
				# Then we break out of the loop
				break
			# If it's not a letter but only one character we still keep going	
			print err_msg_let
		# If it's not a single character
		else:
			print err_msg_one
    
    # Regardless of what was entered, the letter is now lowercase	
	letter = letter.lower()
	
	# If the letter has already been guessed, tell the user then go back to the beginning
	if letter in guesses:
		print err_msg_gss
		continue
	# Otherwise we'll add it to the list
	else:
		guesses += letter
	
	# This seems a little redundant, need to reimplement
	new_word = compare_words(word)	
	
	# If the letter is not one in the word we're guessing
	if letter not in word:
		# Take away one try
		tries -= 1
		print incor_msg % tries
	else:
		print correct_msg
	
	# Display the user's current guesses and progress
	print "\nCurrent guesses: %s" % guesses
	print "%s\n\n" % new_word
	
	# If the user successfully guesses the word
	if new_word == word:
		print win_msg % word
		# Ask to play again and reset game if yes
		again = raw_input("Play again? (Y/n) > ")
		if again == "y" or again == "Y": 
			counter = 1
		else:
			exit(0)	
	# But if the user lost...
	elif tries == 0:
		print lose_msg % word
		again = raw_input("Play again? (Y/n) > ")
		if again == "y" or again == "Y": 
			counter = 1
		else:
			exit(0)	
	# If the user has not lost or won yet, go back to the beginning
	else:
		continue





