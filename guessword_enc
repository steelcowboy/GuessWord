#!/usr/bin/env python2
# -*- coding: utf-8 -*-

# See guessword for explanation of everything

from sys import exit
import random, os, argparse, string
from termcolor import colored
from os.path import exists
from simplecrypt import encrypt, decrypt

parser = argparse.ArgumentParser()
parser.add_argument("-d", "--dictionary", 
                    help="specify text file for words")
parser.add_argument("-l", "--level", type=int, choices=[1,2,3],
					help="""choose a difficulty level (default is 1): 
					level 1 is fifteen incorrect guesses,
					level 2 is ten incorrect guesses
					and level 3 is five incorrect guesses
					""")
parser.add_argument("-r", "--random", action="store_true",
					help = "choose random word from dictionary")
args = parser.parse_args()

# This allows us to decrypt the input file
def decrypt_file(file_name, key):
    with open(file_name, 'rb') as fo:
        ciphertext = fo.read()
    dec = decrypt(key, ciphertext)
    return dec

def get_list():
	dict_file = decrypt_file(args.dictionary, 'password')
	hang_list = dict_file.splitlines()
	hang_list = filter(None, hang_list)
	return hang_list
      
def get_word():
	global word
	if args.random:
		if exists("random.txt"):
			dict_file = "random.txt"
			hang_list = open(dict_file).read().splitlines()
			hang_list = filter(None, hang_list) 
			word = random.choice(hang_list)
		else:
			import requests
			word_site = "http://svnweb.freebsd.org/csrg/share/dict/words?view=co&content-type=text/plain"
			response = requests.get(word_site)
			words = response.content.splitlines()
			word = random.choice(words)
		
	elif args.dictionary:
		# We decrypt the input file and use that now. However, now we don't need to open it
		hang_list = get_list()
		word = random.choice(hang_list)

	else:
		print """
		No dictionary selected. Please either use a random word with
		the "-r" option or choose a dictionary file with "-d".
		"""
		exit(0)	
	word = word.lower()
	return word

# Based on the selected level define how many incorrect guesses. 
# If none selected, default to 20
def get_tries():
	global tries
	if args.level == 1:
		tries = 15 
	elif args.level == 2:
		tries = 10 
	elif args.level == 3:
		tries = 5
	else:
		tries = 15
	return tries
	
# This tells us our progress	
def compare_words(word):
	# First create a blank variable for progress
	new_word = ''
	# Loop through the letters in our word
	for char in word:
		# If the character in the word matches one we've guessed, write it
		if char in guesses: 
			new_word += char
		# Otherwise leave it blank until we guess it
		else:
			new_word += " _ "
	# This tells the function to output, so 
	# we store the value of the function itself in a new variable
	return new_word				

# Ask the user if they'd like to play again; if not just exit
def play_again():
	again = raw_input("Play again? (Y/n) > ")
	if again == "y" or again == "Y": 
		global counter
		counter = 1
	else:
		exit(0)	

# Game
counter = 1
while True:
	if counter == 1:
		guesses = ''
		word = get_word()	
		tries = get_tries()
	else:
		pass
		
	counter += 1
	
	# Decide whether or not to colorize output
	color_output()
	new_word = compare_words(word)
	
	# We use a while loop to keep prompting the user for a single letter
	while True:
		letter = raw_input("Guess a letter: ")
		if len(letter) == 1:
			# Until the input is one letter (not a symbol or number)
			if letter in string.letters:
				# Then we break out of the loop
				break
			# If it's not a letter but only one character we still keep going	
			print err_msg_let
		# If it's not a single character
		else:
			print err_msg_one
    
    # Regardless of what was entered, the letter is now lowercase	
	letter = letter.lower()
	
	# If the letter has already been guessed, tell the user then go back to the beginning
	if letter in guesses:
		print err_msg_gss
		continue
	# Otherwise we'll add it to the list
	else:
		guesses += letter
	
	new_word = compare_words(word)	
	
	# If the letter is not one in the word we're guessing
	if letter not in word:
		# Take away one try
		tries -= 1
		print incor_msg % tries
	else:
		print correct_msg
	
	# Display the user's current guesses and progress
	print "\nCurrent guesses: %s" % guesses
	print "%s\n\n" % new_word
	
	# If the user successfully guesses the word
	if new_word == word:
		print win_msg % word
		play_again()
	# But if the user lost...
	elif tries == 0:
		print lose_msg % word
		play_again()
	# If the user has not lost or won yet, go back to the beginning
	else:
		continue
